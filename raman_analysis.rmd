---
title: "Raman peak assignment"
author: "Leonard Blaschek"
date: "05-08-2019"
output:
    html_document
#   pdf_document:
#     latex_engine: lualatex
#     fig_caption: yes
#     fig_height: 6
#     includes:
#       in_header: rmd_temp.tex
# sansfont: Cooper Hewitt
# monofont: IBM Plex Mono
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ropls)
library(factoextra)
library(cowplot)
library(showtext)
library(ggthemes)
library(plotly)
library(zoo)
library(kableExtra)
library(tidyverse)
library(ggrepel)
library(gplots)
library(viridis)
library(ggridges)
library(RColorBrewer)
library(tukeygrps)

#### import CooperHewitt ####
font_add(
  "Helvetica",
  regular = "/prop_fonts/01. Helvetica   [1957 - Max Miedinger]/HelveticaNeueLTStd-Lt.otf",
  italic = "/prop_fonts/01. Helvetica   [1957 - Max Miedinger]/HelveticaNeueLTStd-LtIt.otf",
  bold = "/prop_fonts/01. Helvetica   [1957 - Max Miedinger]/HelveticaNeueLTStd-Bd.otf",
  bolditalic = "/prop_fonts/01. Helvetica   [1957 - Max Miedinger]/HelveticaNeueLTStd-BdIt.otf"
)
showtext_auto()

#### generating plot theme ####
theme_leo <- function(base_size = 18,
                      base_family = "Helvetica") {
  theme_minimal(
    base_size = base_size,
    base_family = base_family
  ) %+replace%
    theme(
      strip.text = element_text(hjust = 0, face = "italic"),
      axis.ticks = element_line(
        size = 0.25,
        lineend = "square",
        color = "black"
      ),
      axis.text.x = element_text(
        colour = "black", # flipped coords
        margin = margin(1, 1, 1, 1)
      ),
      axis.text.y = element_text(
        colour = "black",
        angle = 0,
        vjust = 0.5,
        hjust = 1,
        margin = margin(1, 1, 1, 1)
      ),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_rect(fill = NA, color = "black", size = 0.25),
      panel.spacing = unit(1.5, "mm"),
      legend.position = "none",
      legend.text = element_text(size = rel(0.8)),
      legend.key.height = unit(4, "mm"),
      complete = TRUE
    )
}

scale_range <- function(x){(x-min(x))/(max(x)-min(x))}
scale_z <- function(x){(x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)}
scale_max <- function(x){x / max(x)}
scale_lig <- function(x){x / max(x[wavenumber > 1590 & wavenumber < 1610])}
```

## Raman peaks from the literature

I started with a list of peaks from the literature for orientation. The precise position of these peaks reportedly varies up to ± 5 cm^-1^ between different species.

```{r literature, warning = FALSE, message = FALSE, echo = FALSE}
rmn_tab <- read_csv("/home/leonard/Documents/Uni/PhD/Raman/raman_peak_assignments.csv")
kable(rmn_tab, caption = "Table 1: Peaks previously identified as diagnostic for lignin and cellulose.") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Wild type spectra

Here are our wild type spectra in absolute Raman intensity. The black line shows the average, the other lines are individual spectra, coloured by sampled plant.

```{r load data, warning = FALSE, message = FALSE, echo = FALSE}
rmn_data <- read_csv("Raman_corrected_and_filtered.csv")
rmn_data$replicate <- as.factor(rmn_data$replicate)
rmn_data$technical <- as.factor(rmn_data$technical)
```

```{r plot spectra, out.width = '100%', fig.showtext = TRUE, warning = FALSE, message = FALSE, echo = FALSE}
rmn_data_pre <- rmn_data %>%
  group_by(genotype, cell.type, replicate, wavenumber) %>%
  summarise(
    mean.intensity.pre = mean(corrected.intensity, na.rm = TRUE),
    sd.intensity.pre = sd(corrected.intensity, na.rm = TRUE),
    samples.pre = length(corrected.intensity),
    mean.scaled = mean(scaled, na.rm = TRUE)
  )

rmn_data_avg <- rmn_data_pre %>%
  group_by(genotype, cell.type, wavenumber) %>%
  summarise(
    mean.intensity = mean(mean.intensity.pre, na.rm = TRUE),
    sd.intensity = sd(mean.intensity.pre, na.rm = TRUE),
    plants = paste("plants: ", length(mean.intensity.pre)),
    bundles = ifelse(length(mean.intensity.pre) > 1,
      paste("cells/plant: ", min(samples.pre), "—", max(samples.pre), sep = ""),
      paste("cells/plant: ", min(samples.pre))
    ),
    mean.scaled = mean(mean.scaled, na.rm = TRUE)
  )

rmn_data_avg_WT <- filter(rmn_data_avg, genotype == "Col-0" & cell.type %in% c("PMX", "IF"))
rmn_data_pre_WT <- filter(rmn_data_pre, genotype == "Col-0" & cell.type %in% c("PMX", "IF"))
rmn_data_WT <- filter(rmn_data, genotype == "Col-0" & cell.type %in% c("PMX", "IF"))
rmn_data_WT <- rmn_data_WT %>%
  unite("grouptech", replicate, technical, remove = FALSE)

#### plotting unscaled spectra ####
spectra.WT.MX <- ggplot() +
  geom_line(
    data = rmn_data_WT,
    aes(
      x = wavenumber,
      y = rollmean(corrected.intensity, 3, na.pad = TRUE),
      colour = replicate,
      group = grouptech
    ),
    size = 0.4,
    alpha = 0.25
  ) +
  geom_line(
    data = rmn_data_avg_WT,
    aes(x = wavenumber, y = rollmean(mean.intensity, 3, na.pad = TRUE)),
    size = 0.2
  ) +
  scale_x_reverse(limits = c(2000, 300)) +
  scale_y_continuous(limits = c(-1000, 14500)) +
  scale_fill_viridis_d() +
  scale_colour_few() +
  labs(
    x = "Wavenumber",
    y = "Corrected intensity"
  ) +
  theme_leo() +
  geom_text(
    data = subset(rmn_data_avg_WT, wavenumber == 1430),
    x = 1950,
    y = 14500,
    aes(label = plants),
    stat = "identity",
    family = "Helvetica",
    size = 2.5,
    hjust = 1
  ) +
  geom_text(
    data = subset(rmn_data_avg_WT, wavenumber == 1430),
    x = 1950,
    y = 13500,
    aes(label = bundles),
    stat = "identity",
    family = "Helvetica",
    size = 2.5,
    hjust = 1
  ) +
  facet_grid(cell.type ~ genotype)
ggplotly(spectra.WT.MX)
```

## Scaled wild type spectra

Here are the WT spectra normalised to the intensity at 1603 cm^-1^, which should acount for different proportions of lumen to cell wall in the individual measurements and give us a better representation of relative cell wall composition.

```{r plot scaled spectra, out.width = '100%', fig.showtext = TRUE, warning = FALSE, message = FALSE, echo = FALSE}
#### plotting scaled spectra ####
spectra.WT.scaled <- ggplot() +
  geom_line(
    data = rmn_data_avg_WT,
    aes(
      x = wavenumber,
      y = rollmean(mean.scaled, 3, na.pad = TRUE),
      colour = cell.type
    ),
    size = 1,
    alpha = 1
  ) +
  scale_x_reverse(limits = c(2000, 300)) +
  # scale_y_continuous(limits = c(-0.1, 1)) +
  scale_fill_viridis_d() +
  scale_colour_few() +
  theme_leo() +
  labs(
    x = "Wavenumber",
    y = "Normalised intensity",
    title = "Col-0"
  )
ggplotly(spectra.WT.scaled)
```

## Clustering of mutant spectra

This is an overview and clustering of our scaled mutant IF and PMX spectra. The lignin deficient IFs cluster together based on their high relative cellulose content (*ccr1*, *4cl1*, *4cl1/2*, wavenumbers around 1100/1120 cm^⁻1^), but other patterns are harder to distinguish.

```{r cluster, fig.showtext = TRUE, out.width = '100%', warning = FALSE, message = FALSE, echo = FALSE}
rmn_data_spread <- rmn_data %>%
  filter(cell.type %in% c("PMX", "IF")) %>%
  select(-intensity, -corrected.intensity) %>%
  spread(key = wavenumber, value = scaled)

rmn_data_mat <- rmn_data_spread %>%
  select(-replicate, -technical) %>%
  group_by(genotype, cell.type) %>%
  summarise_all(list(mean)) %>%
  ungroup()
rmn_mat <- as.matrix(select(rmn_data_mat, -genotype, -cell.type))
rwnms <- unite(rmn_data_mat, "ID", genotype, cell.type, sep = "_")
rownames(rmn_mat) <- rwnms$ID
heatmap.2(rmn_mat,
  Colv = FALSE,
  col = viridis,
  trace = "none",
  symbreaks = FALSE
)
```

## Spectral variation between cell walls

Above we saw that the variation between IF and MX of the WT was specific to a handful of wavenumbers. Next, this is the overall variation across MX and IF in all our genotypes. The spectrum below is coloured according to the standard deviation of the raman intensities at the respective wavenumber. The labels are peak assignments from the literature (see table 1).

```{r plot variation spectra, out.width = '100%', message = FALSE, warning = FALSE, echo = FALSE, fig.showtext = TRUE}
rmn_data_var <- rmn_data %>%
  group_by(wavenumber) %>%
  summarise(
    mean.scaled = mean(scaled, na.rm = TRUE),
    st.dev = sd(scaled, na.rm = TRUE)
  ) %>%
  left_join(select(rmn_tab, wavenumber, Polymer, Substructure) %>%
    unite(lbl, Polymer, Substructure, sep = ", ") %>%
    mutate(
      wavenumber = as.numeric(wavenumber),
      lbl = str_replace_all(lbl, "\\~", "")
    ))

#### plotting scaled spectra ####
ggplot(data = rmn_data_var, aes(
  y = rollmean(mean.scaled, 3, na.pad = TRUE),
  x = wavenumber
)) +
  geom_ridgeline_gradient(aes(
    height = 1 - rollmean(mean.scaled, 3, na.pad = TRUE),
    fill = st.dev
  ),
  colour = "white"
  ) +
  scale_x_reverse(limits = c(2000, 300)) +
  labs(
    x = "Wavenumber",
    y = "Normalised intensity"
  ) +
  scale_fill_viridis_c() +
  theme_leo() +
  theme(
    legend.position = "bottom",
    legend.key.width = unit(4, "mm")
  ) +
  guides(fill = guide_legend()) +
  geom_label_repel(aes(label = lbl),
    nudge_y = 0.25,
    family = "Helvetica",
    segment.colour = "red",
    size = 5
  )
```

```{r opls-da iterate, fig.showtext = TRUE, out.width = '100%', include = FALSE, echo = FALSE}
#### compute and save OPLS-DA iterations ####
# oplsda_iter <- function(x, b, y, z) {
#   rmn_mat <- data.matrix(x %>%
#     filter(genotype %in% c(y, z) & cell.type == b) %>%
#     select(-genotype, -cell.type, -replicate, -technical))
#   rwnms <- x %>%
#     filter(genotype %in% c(y, z) & cell.type == b) %>%
#     select(genotype, cell.type, replicate, technical) %>%
#     unite("ID", genotype, cell.type, replicate, technical, sep = "_")
#   rownames(rmn_mat) <- rwnms$ID
#   rmn_meta <- as.matrix(x %>%
#     filter(genotype %in% c(y, z) & cell.type == b) %>%
#     select(genotype, cell.type, replicate, technical))
# 
#   genotype <- rmn_meta[, "genotype"]
#   rmn_oplsda <- opls(rmn_mat, genotype, predI = 1, orthoI = 1, crossvalI = 5)
#   
#   loading <- as_tibble(getLoadingMN(rmn_oplsda), rownames = "wavenumber") %>%
#   rename(loading = p1) %>%
#   mutate(wavenumber = as.numeric(wavenumber))
#   return(loading)
# }
# 
# celltype_list <- list(
#   "IF",
#   "PMX"
# )
# geno_list <- list(
#   "Col-0",
#   "4cl1",
#   "4cl2",
#   "4cl1x4cl2",
#   "ccoaomt1",
#   "fah1",
#   "omt1",
#   "ccr1-3",
#   "cad4",
#   "cad5",
#   "cad4xcad5"
# )
# 
# loadings <- vector("list", 1)
# for (h in celltype_list){
#   for(i in geno_list){
#     for(j in geno_list){
#       if(i == j) next
#       loadings[[paste(h, i, j, sep = "_")]] <- oplsda_iter(rmn_data_spread, h, i, j)
#     }
#   }
# }
# 
# loadings_df <- loadings[-1] %>% 
#   kimisc::list_to_df() %>% 
#   unnest() %>%
#   spread(key = wavenumber, value = loading) %>%
#   separate(name, sep = "_", into = c("cell.type", "genotype_1", "genotype_2"))
# 
# loadings_df <- loadings_df[!duplicated(t(apply(loadings_df[c("cell.type","genotype_1", "genotype_2")], 1, sort))), ]
# 
# loadings_df_mean <- loadings_df %>%
#   gather(key = "wavenumber", value = "loading", - cell.type, - genotype_1, - genotype_2) %>%
#   mutate(wavenumber = as.numeric(wavenumber)) %>%
#   group_by(wavenumber) %>%
#   summarise(loading.mean = mean(abs(loading)))
# 
# write_csv(loadings_df_mean, "loadings_df_mean.csv")
# 
# rmn_data_loading <- rmn_data %>%
#   group_by(wavenumber) %>%
#   summarise(
#     mean.scaled = mean(scaled, na.rm = TRUE)
#   ) %>%
#   left_join(loadings_df_mean) %>%
#   left_join(select(rmn_tab, wavenumber, Polymer, Substructure) %>%
#     unite(lbl, Polymer, Substructure, sep = ", ") %>%
#     mutate(
#       wavenumber = as.numeric(wavenumber),
#       lbl = str_replace_all(lbl, "\\~", "")
#     ))
# 
# write_csv(rmn_data_loading, "rmn_data_loading.csv")

#### read in OPLS-DA iterations if previously computed ####
rmn_data_loading <- read_csv("rmn_data_loading.csv")
loadings_df_mean <- read_csv("loadings_df_mean.csv")
```

## Multivariate analysis by OPLS-DA

To pin down the wavenumbers that can be used to distinguish between cell walls with different lignin composition, I ran iterative OPLS-DA analyses comparing all combinations of cell type and genotype. I then took the average absolute loading of each wavenumber and coloured the spectrum accordingly. Wavenumbers in yellow are therefore consistently more diagnostic for changes in lignin composition than the others. The annotations are from the literature and identical to the figure before.

```{r, fig.showtext = TRUE, out.width = '100%', warning = FALSE, message = FALSE, echo = FALSE}
ggplot(data = rmn_data_loading, aes(
  y = rollmean(mean.scaled, 3, na.pad = TRUE),
  x = wavenumber
)) +
  geom_ridgeline_gradient(aes(
    height = 1 - rollmean(mean.scaled, 3, na.pad = TRUE),
    fill = loading.mean
  ),
  colour = "white"
  ) +
  scale_x_reverse(limits = c(2000, 300)) +
  labs(
    x = "Wavenumber",
    y = "Normalised intensity"
  ) +
  scale_fill_viridis_c() +
  theme_leo() +
  theme(
    legend.position = "bottom",
    legend.key.width = unit(4, "mm")
  ) +
  guides(fill = guide_legend()) +
  geom_label_repel(aes(label = lbl),
    nudge_y = 0.25,
    family = "Helvetica",
    segment.colour = "red",
    size = 5
  )
```

## Identification of diagnostic peaks

Based on the average loading (above), annotations from the literature, and whether a peak at that position is distinguishable in our spectra, I then identified a number of peaks that are likely of primary interest to us. The peak assignments are according to the literature. For our own assignments, I would want to wait for the respective monomer/DHP spectra.

```{r peak clusters, fig.showtext = TRUE, out.width = '100%', warning = FALSE, message = FALSE, echo = FALSE}
options(knitr.kable.NA = '')

selected_peaks <- read_csv("/home/leonard/Documents/Uni/PhD/Raman/raman_peak_detection.csv")

kable(selected_peaks,
  caption = "Table 2: Peaks crucial for mutat distinction.",
  col.names = c(
    "Peak",
    "Wavenumber",
    "Closest reported peak",
    "Assigned bond",
    "Assigned polymer",
    "Assigned structure",
    "Reference"
  )
) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

rmn_data_loading <- rmn_data %>%
  group_by(wavenumber) %>%
  summarise(
    mean.scaled = mean(scaled, na.rm = TRUE)
  ) %>%
  left_join(loadings_df_mean) %>%
  left_join(select(selected_peaks, peak, wavenumber) %>%
    mutate(wavenumber = as.numeric(wavenumber)))

ggplot(data = rmn_data_loading, aes(
  y = rollmean(mean.scaled, 3, na.pad = TRUE),
  x = wavenumber
)) +
  geom_ridgeline_gradient(aes(
    height = 1 - rollmean(mean.scaled, 3, na.pad = TRUE),
    fill = loading.mean
  ),
  colour = "white"
  ) +
  scale_x_reverse(limits = c(2000, 300)) +
  labs(
    x = "Wavenumber",
    y = "Normalised intensity"
  ) +
  scale_fill_viridis_c() +
  theme_leo() +
  theme(
    legend.position = "bottom",
    legend.key.width = unit(4, "mm")
  ) +
  guides(fill = guide_legend()) +
  geom_label_repel(aes(label = peak),
    nudge_y = 0.25,
    family = "Helvetica",
    segment.colour = "red",
    size = 4
  )
```

## The case for deconvolution

Here is a close up of the main lignin peak around 1600 cm^-1^, clearly indicating that it is the product of a number of individual peaks. While I agree that deconvolution of minor or even "invisible" peaks is a questionable practice, I think we could have success with this one. Depending of course on our ability to decipher the contribution peaks with the monomers/DHPs.

```{r peak close-up, fig.showtext = TRUE, out.width = '100%', warning = FALSE, message = FALSE, echo = FALSE}

rmn_data_ridge <- rmn_data %>%
  filter(
    wavenumber > 1550 & 
           wavenumber < 1650 & 
           genotype != "ccr1xfah1" &
           cell.type %in% c("IF", "PMX")) %>%
  ungroup() %>%
  mutate(genotype = ordered(genotype, levels = c(
  "Col-0",
  "4cl1",
  "4cl2",
  "4cl1x4cl2",
  "ccoaomt1",
  "fah1",
  "omt1",
  "ccr1-3",
  "ccr1xfah1",
  "cad4",
  "cad5",
  "cad4xcad5"
)))

# pdf("peak1600_ridge.pdf")
ggplot(data = rmn_data_ridge) + 
  geom_ridgeline(aes(
    x = wavenumber, 
    y = genotype, 
    height = rollmean(scaled, 10, na.pad = TRUE), 
    fill = genotype, 
    group = interaction(genotype, replicate, technical)
    ),
    alpha = 0.25,
    size = 0.2,
    # colour = NA,
    scale = 1.5
    ) +
  scale_fill_viridis_d() +
  scale_y_discrete(
    labels = c(
      "Col-0",
      expression(italic("4cl1")),
      expression(italic("4cl2")),
      expression(paste(italic("4cl1"), "x", italic("4cl2"))),
      expression(italic("ccoaomt1")),
      expression(italic("fah1")),
      expression(italic("omt1")),
      expression(italic("ccr1")),
      expression(italic("cad4")),
      expression(italic("cad5")),
      expression(paste(italic("cad4"), "x", italic("cad5")))
    )
  ) +
  theme_leo() +
  theme(panel.spacing = unit(5, "mm"),
        axis.title.y = element_blank()) +
  geom_vline(xintercept = 1603, colour = "grey", alpha = 0.75, size = 2) +
  facet_wrap(~ cell.type, ncol = 2)
# dev.off()

```

## Validating multiple peaks per unit/monomer

As you saw in the tables, there is numerous peaks supposedly diagnostic for single lignin monomers. If that were true, these peaks would correlate perfectly with each other across our samples. Below you see a correlattion matrix showing that that is not the case. Although there are some distinguishable clusters for G and S units, the picture is far from clear. This figure looks different from the one I printed out for you but holds the same information. In this one you can hove over the plot to extract the precise pearson's coefficients and annotations.

```{r overall corrplot, fig.showtext = TRUE, out.width = '100%', warning = FALSE, message = FALSE, echo = FALSE, fig.height = 10}
library(heatmaply)
library(NMF)
rmn_data_filled <- rmn_data %>%
  ungroup() %>%
  group_by(genotype, cell.type, replicate, technical) %>%
  complete(wavenumber = seq(min(wavenumber), max(wavenumber), by = 1)) %>%
  mutate(filled = rollapply(corrected.intensity, 
                            width = 5, 
                            FUN = function(x) mean(x, na.rm = TRUE), 
                            # by = 1, 
                            # by.column = TRUE, 
                            partial = TRUE, 
                            fill = NA, 
                            align = "center"))

peak_df <- read_csv("/home/leonard/Documents/Uni/PhD/Raman/all_lit_peaks.csv") %>%
  mutate("assigned bond" = replace_na(`assigned bond`, "unassigned"),
         "assigned subunit" = replace_na(`assigned subunit`, "unassigned"))
rmn_mat <- rmn_data_filled %>%
  unite(ID, genotype, cell.type, replicate, technical, sep = "_") %>%
  select(ID, wavenumber, filled) %>%
  filter(wavenumber %in% peak_df$wavenumber) %>%
  spread(key = wavenumber, value = filled) %>%
  column_to_rownames(var = "ID")

rmn_cor <- cor(as.matrix(rmn_mat))

col4 <- brewer.pal(4, "YlGnBu")
col6 <- brewer.pal(6, "Dark2")

heatmaply_cor(rmn_cor,
              k_row = 3,
              k_col = 8,
              colors = c("#313695", "#abd9e9", "#ffffbf", "#fdae61", "#a50026"),
              row_side_colors = peak_df$`assigned polymer`,
              col_side_colors = peak_df$`assigned subunit`,
              column_text_angle = 90,
              hide_colorbar = TRUE)


# aheatmap(rmn_cor, 
#          annCol = peak_df[, c(3, 4)],
#          Rowv = FALSE,
#          annColors = list(`assigned subunit` = col6, `assigned polymer` = col4))
```

## Distinction of S and 5-OH-G specific peaks

Based on the above clústering, there are two groups of potentially S-unit specific peaks. My hope was that one of these is specific the S-units (methoxy group) and the other was sensitive to both methoxy groups and the additional hydroxy group of the 5-OH-G units. I therefore plotted the scaled intensities of these peaks in WT, *fah1* and *omt1*, coloured by peak group. Unfortunately, the picture is not quite clear, showing distinctions between WT and mutants and between the mutants (albeit with *P* > 0.05) in both groups. Spectra of 5-OH-G would be helpful for this, but I did not give Zoltan the 5-OH-G acid yet.

```{r S-peaks, fig.showtext = TRUE, out.width = '100%', warning = FALSE, message = FALSE, echo = FALSE}
library(tukeygrps)
rmn_data_wavenumbers <- rmn_data %>%
  select(-intensity, -corrected.intensity) %>%
  filter(cell.type %in% c("IF", "PMX") & genotype != "ccr1xfah1") %>%
  group_by(genotype, cell.type, replicate, technical) %>%
  filter(wavenumber %in% c(
    1149,
    1338,
    1396,
    1461,
    1129,
    1367,
    1384
  ) & genotype %in% c("Col-0", "fah1", "omt1")) %>%
  mutate(cluster = case_when(
    wavenumber %in% c(1149, 1338, 1396) ~ "1",
    wavenumber %in% c(1461, 1129, 1367, 1384) ~ "2"
  ),
  wavenumber = ordered(wavenumber, levels = c(
    "1149",
    "1338",
    "1396",
    "1461",
    "1129",
    "1367",
    "1384"
  ))
  )

raman.letters <- letter_groups(rmn_data_wavenumbers, scaled, genotype, "tukey", cell.type, wavenumber)

# raman.letters$value <- ifelse(raman.letters$variable == "lig.peak.pos", 1585, raman.letters$value)

# pdf("raman_peaks.pdf", width = 7, height = 20)
ggplot(data = rmn_data_wavenumbers, aes(x = genotype, y = scaled)) +
  geom_rect(aes(y = NULL,
                x = NULL,
                fill = cluster),
    xmin = -Inf,
    xmax = Inf,
    ymin = -Inf,
    ymax = Inf
  ) +
  geom_jitter(
    # aes(fill = scaled),
    shape = 21,
    width = 0.1,
    alpha = 0.9,
    size = 2,
    stroke = 0.25
  ) +
  # geom_violin(draw_quantiles = 0.5, adjust = 1.5, fill = rgb(1,1,1,0.5)) +
  geom_boxplot(fill = rgb(1, 1, 1, 0.5), outlier.alpha = 0) +
  geom_text(
    data = raman.letters,
    aes(label = groups),
    angle = 0,
    hjust = 0,
    vjust = 0.5,
    family = "Helvetica",
    size = 6
  ) +
  # scale_fill_distiller(palette = "RdBu", name = "Z-score by\nrow") +
  scale_y_continuous(expand = expand_scale(mult = c(0.2, 0.05))) +
  scale_x_discrete(
    labels = c(
      "Col-0",
      expression(italic("fah1")),
      expression(italic("omt1"))
    )
  ) +
  theme_leo() +
  theme(axis.title = element_blank()) +
  facet_grid(wavenumber ~ cell.type,
    scales = "free_y"
  ) +
  coord_flip()
# dev.off()

```